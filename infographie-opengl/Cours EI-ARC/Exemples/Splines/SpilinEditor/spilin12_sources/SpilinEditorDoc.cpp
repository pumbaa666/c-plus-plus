/*****************************************************
Copyright Notice

Copyright © Alessandro Falappa

Permission to use, copy, modify, and distribute this software
and its documentation for any purpose is hereby granted without
fee, provided that the above copyright notice, author statement
appear in all copies of this software and related documentation.

THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF
ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT
LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.

IN NO EVENT SHALL ALESSANDRO FALAPPA BE LIABLE FOR ANY
SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE,
AND ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
******************************************************/
// SpilinEditorDoc.cpp : implementation of the CSpilinEditorDoc class
//

#include "stdafx.h"
#include "SpilinEditor.h"
#include "math.h"
#include "float.h"

#include "Persist.h"
#include "SplitWndEx.h"
#include "MainFrm.h"
#include "undo.h"
#include "SpilinEditorDoc.h"
#include "SpilinEditorView.h"
#include "GLView.h"
#include "VrmlExpDlg.h"
#include "SettingSheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants
const int SEZIONI=24;
const int STEPS=10;
const int PREVSTEPS=5;

// global data structures for garbage collection
// for deletion of vertex generated by tessellation
struct GLvertpunt{
	GLdouble *pvert;
	GLvertpunt* next;
};
static GLvertpunt* garbagelist;

static void AddGarbage(GLdouble * punt)
{
	ASSERT(punt!=NULL);
	ASSERT(punt[2]!=0.0);
	GLvertpunt* temp=new GLvertpunt;
	temp->pvert=punt;
	temp->next=garbagelist;
	garbagelist=temp;
}

static void DeleteGarbage()
{
	ASSERT(garbagelist!=NULL);
	GLvertpunt* punt=garbagelist;
	GLvertpunt* temp=garbagelist;
	while(punt!=NULL)
	{
		delete[] punt->pvert;
		punt=punt->next;
		delete temp;
		temp=punt;
	};
	garbagelist=NULL;
}

// Wrapped Callbacks for gluTessCallback
static void CALLBACK beginCallback(GLenum type)
{
	glBegin(type);
}

static void CALLBACK errorCallback(GLenum errorCode)
{
	const GLubyte *estring;

	estring = gluErrorString(errorCode);
	TRACE("Tessellation Error: %s\n", estring);
}

static void CALLBACK endCallback(void)
{
	glEnd();
}

static void CALLBACK vertexCallback(GLvoid *vertex)
{
	glVertex3dv( (const double *)vertex );
}

static void CALLBACK combineCallback(GLdouble coords[3], GLdouble *data[4], GLfloat weight[4], GLdouble **dataOut )
{
	GLdouble *vertex;
	vertex = new GLdouble[3];

	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];
	*dataOut = vertex;
	AddGarbage(vertex);
}

/////////////////////////////////////////////////////////////////////////////
// CSpilinEditorDoc

IMPLEMENT_DYNCREATE(CSpilinEditorDoc, CDocument)

BEGIN_MESSAGE_MAP(CSpilinEditorDoc, CDocument)
	//{{AFX_MSG_MAP(CSpilinEditorDoc)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_STEPS, OnUpdateSteps)	// manage steps indicator on statusbar
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_NODI, OnUpdateNodi)	// manage nodes indicator on statusbar
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_POLYGONS, OnUpdatePolygons)	// manage polygonsindicator on statusbar
	ON_COMMAND(ID_FILE_ESPORTAINPOV, OnFileEsportainpov)
	ON_COMMAND(ID_FILE_ESPORTAINVRML20, OnFileEsportainvrml20)
	ON_COMMAND(ID_FLIP_N, OnFlipN)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_SNAP, OnSnap)
	ON_COMMAND(ID_REVOLUTION, OnRevolution)
	ON_COMMAND(ID_ESTRUSION, OnEstrusion)
	ON_COMMAND(ID_SMOOTH_SHADE, OnSmoothShade)
	ON_UPDATE_COMMAND_UI(ID_ESTRUSION, OnUpdateEstrusion)
	ON_UPDATE_COMMAND_UI(ID_REVOLUTION, OnUpdateRevolution)
	ON_COMMAND(ID_STATO_CREA, OnStatoCrea)
	ON_COMMAND(ID_STATO_INSER, OnStatoInser)
	ON_COMMAND(ID_STATO_MODIFICA, OnStatoModifica)
	ON_COMMAND(ID_STATO_SELECT, OnStatoSelect)
	ON_COMMAND(ID_SETTINGS, OnSettings)
	ON_COMMAND(ID_VIEW_GRIDPLANE, OnViewGridplane)
	ON_UPDATE_COMMAND_UI(ID_VIEW_GRIDPLANE, OnUpdateViewGridplane)
	ON_COMMAND(ID_STATO_RUOTA, OnStatoRuota)
	ON_UPDATE_COMMAND_UI(ID_STATO_RUOTA, OnUpdateStatoRuota)
	ON_UPDATE_COMMAND_UI(ID_STATO_CREA, OnUpdateStatoCrea)
	ON_UPDATE_COMMAND_UI(ID_STATO_INSER, OnUpdateStatoInser)
	ON_UPDATE_COMMAND_UI(ID_STATO_MODIFICA, OnUpdateStatoModifica)
	ON_UPDATE_COMMAND_UI(ID_STATO_SELECT, OnUpdateStatoSelect)
	ON_COMMAND(ID_STATO_SCALA, OnStatoScala)
	ON_UPDATE_COMMAND_UI(ID_STATO_SCALA, OnUpdateStatoScala)
	ON_COMMAND(ID_MODIFICA_CHIUDISPLINE, OnModificaChiudispline)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_COMMAND(ID_EDIT_SELECT_NONE, OnEditSelectNone)
	ON_UPDATE_COMMAND_UI(ID_STATO_MIRROR_X, OnUpdateStatoMirrorX)
	ON_UPDATE_COMMAND_UI(ID_STATO_MIRROR_Y, OnUpdateStatoMirrorY)
	ON_UPDATE_COMMAND_UI(ID_MODIFICA_CHIUDISPLINE, OnUpdateModificaChiudispline)
	ON_COMMAND(ID_STATO_MIRROR_X, OnStatoMirrorX)
	ON_COMMAND(ID_STATO_MIRROR_Y, OnStatoMirrorY)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSpilinEditorDoc construction/destruction

CSpilinEditorDoc::CSpilinEditorDoc():
	numnodi(0) , numsteps(STEPS) , numstepspreview(PREVSTEPS) ,
	listaprimo(NULL) , listaultimo(NULL) , corr(NULL) ,
	chiusa(FALSE) , Rdisplist(0) , Edisplist(0) , Esidedisplist(0),
	sezsolido(SEZIONI) , pviewnormflip(FALSE) ,
	exportHeight(1.0f), pviewHeight(0.5f), exportObjType(LATHE),
	cmapfactor(1), proportional(FALSE), exportObjName("untitled"),
	exportConic(FALSE), exportSturm(FALSE), exportOpen(FALSE),
	pEditView(NULL), pGLView(NULL)
{
	garbagelist=NULL;
	RetrieveSettings();
	EnableCheckPoint();
}

CSpilinEditorDoc::~CSpilinEditorDoc()
{
	SaveSettings();
	if(garbagelist!=NULL) DeleteGarbage();
}

BOOL CSpilinEditorDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	chiusa=FALSE;
	pGLView->objtype=LATHE;
	Rdisplist=0;
	Edisplist=0;
	Esidedisplist=0;
	CheckPoint();

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CSpilinEditorDoc serialization

void CSpilinEditorDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		try
		{
		ar<<"SPILINV1.2";
		ar<<chiusa<<numnodi;
		nodo *punt=listaprimo;
		while(punt!=NULL)
		{
			ar<<punt->pun.x<<punt->pun.y<<punt->selected;
			punt=punt->succ;
		};
		}
		catch( CFileException* e )
		{
		AfxMessageBox("   Error while saving file!",MB_OK | MB_ICONEXCLAMATION);
		#ifdef _DEBUG
		afxDump << "File Name: "<<e->m_strFileName<<"\nCFile Error Code: " << e->m_cause << "\n";
		#endif
		e->Delete();
		return;
		}
		catch( CArchiveException* e )
		{
		AfxMessageBox("   Error while saving file!",MB_OK | MB_ICONEXCLAMATION);
		#ifdef _DEBUG
		afxDump << "CArchive Error Code: " << e->m_cause << "\n";
		#endif
		e->Delete();
		return;
		}
		SetModifiedFlag(FALSE);
	}
	else//Load
	{
		CString formato;
		try
		{
		// exception trowing block
		ar>>formato;
		if (formato=="SPILINV1.0")
		{
			DeleteContents();
			ar>>chiusa>>numnodi;
			if (numnodi >0)
			{
				nodo *temp=new nodo;
				ar>>temp->pun.x>>temp->pun.y;
				temp->succ=NULL;
				temp->prec=NULL;
				listaultimo=temp;
				listaprimo=temp;
				for(int j=1;j<numnodi;j++)
				{
					nodo *temp=new nodo;
					ar>>temp->pun.x>>temp->pun.y;
					temp->prec=listaultimo;
					temp->succ=NULL;
					listaultimo->succ=temp;
					listaultimo=temp;
				};
			};
		}
		else if (formato == "SPILINV1.2")
				{
					DeleteContents();
					ar>>chiusa>>numnodi;
					if (numnodi >0)
					{
						nodo *temp=new nodo;
						ar>>temp->pun.x>>temp->pun.y>>temp->selected;
						temp->succ=NULL;
						temp->prec=NULL;
						listaultimo=temp;
						listaprimo=temp;
						for(int j=1;j<numnodi;j++)
						{
							nodo *temp=new nodo;
							ar>>temp->pun.x>>temp->pun.y>>temp->selected;
							temp->prec=listaultimo;
							temp->succ=NULL;
							listaultimo->succ=temp;
							listaultimo=temp;
						};
					};
				}
				else AfxMessageBox("   This is not a Spilin Editor file!",MB_OK | MB_ICONEXCLAMATION);
		// end exception throwing block
		}
		catch( CFileException* e )
		{
		AfxMessageBox("   Error while reading file!",MB_OK | MB_ICONEXCLAMATION);
		#ifdef _DEBUG
		afxDump << "File Name: "<<e->m_strFileName<<"\nCFile Error Code: " << e->m_cause << "\n";
		#endif
		e->Delete();
		return;
		}
		catch( CArchiveException* e )
		{
		AfxMessageBox("   Error while reading file!",MB_OK | MB_ICONEXCLAMATION);
		#ifdef _DEBUG
		afxDump << "CArchive Error Code: " << e->m_cause << "\n";
		#endif
		e->Delete();
		return;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSpilinEditorDoc diagnostics

#ifdef _DEBUG
void CSpilinEditorDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CSpilinEditorDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
	afxDump<<"Total Nodes Number :"<<numnodi<<"\n";
	afxDump<<"Closed :"<<chiusa<<"\n";
	nodo *punt=listaprimo;
	int num=1;
	while (punt!=NULL)
	{
		afxDump<<"Node :"<<num<<"\tx:"<<punt->pun.x<<"\ty:"<<punt->pun.y<<"\n";
		num+=1;
		punt=punt->succ;
	};
	afxDump<<"\n";
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CSpilinEditorDoc commands

void CSpilinEditorDoc::canclista()
{
	nodo *corren=listaultimo;
	nodo *pros=listaultimo;
	while (corren!=listaprimo)
	{
		pros=corren->prec;
		delete corren;
		corren=pros;
	};
	delete listaprimo;
}

void CSpilinEditorDoc::DeleteContents() 
{
	canclista();
	chiusa=FALSE;
	listaprimo=NULL;
	listaultimo=NULL;
	corr=NULL;
	numnodi=0;
	CDocument::DeleteContents();
}

void CSpilinEditorDoc::aggnodo(CPoint p)
{
	// x clamping to positive values
	Clamping(p);
	// caso generico
	if(numnodi!=0 && !chiusa)
	{
		numnodi+=1;
		nodo *temp=new nodo;
		temp->pun=p;
		temp->selected=FALSE;
		temp->prec=listaultimo;
		temp->succ=NULL;
		listaultimo->succ=temp;
		listaultimo=temp;
	}
	// caso primo nodo
	else
	{
		numnodi+=1;
		nodo *temp=new nodo;
		temp->pun=p;
		temp->selected=FALSE;
		temp->succ=NULL;
		temp->prec=NULL;
		listaultimo=temp;
		listaprimo=temp;
	};
	CheckPoint();
	SetModifiedFlag();
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::inserisci(CPoint p)
{
	if (numnodi==0)
	{
		aggnodo(p);
		corr=listaprimo;
	}
	else
	{
		// x clamping to positive values
		Clamping(p);
		numnodi+=1;
		nodo *temp=new nodo;
		temp->pun=p;
		temp->selected=FALSE;
		if(corr==listaprimo)
		{// this case occur in closed splines
			temp->succ=listaprimo;
			temp->prec=NULL;
			listaprimo->prec=temp;
			listaprimo=temp;
		}
		else
		{// normal case
			temp->succ=corr;
			temp->prec=corr->prec;
			corr->prec->succ=temp;
			corr->prec=temp;
		};
		corr=temp;
	};
	CheckPoint();
	SetModifiedFlag();
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::chiudi()
{
	if(numnodi>=3)
	{
		chiusa=TRUE;
		CheckPoint();
		SetModifiedFlag();
		UpdateAllViews(NULL);
	};
}


void CSpilinEditorDoc::OnCloseDocument() 
{
	CDocument::OnCloseDocument();
}

BOOL CSpilinEditorDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	if (!CDocument::OnOpenDocument(lpszPathName))
		return FALSE;
	#ifdef _DEBUG
	TRACE("\tDump:\n");
	afxDump<<this;
	#endif
	Rdisplist=0;
	Edisplist=0;
	CheckPoint();
	return TRUE;
}

BOOL CSpilinEditorDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	return CDocument::OnSaveDocument(lpszPathName);
}


void CSpilinEditorDoc::OnFileEsportainpov() 
{
	// Bring up a file-requester
	static char  Filter[] = "POV Include Files (*.inc)|*.inc|POV Scene Files (*.pov)|*.pov|All Files (*.*)|*.*||";
	CFileDialog requester(FALSE,"inc","untitled",OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR,Filter);
	requester.m_ofn.lpstrTitle="POV-Ray Export";
	if (requester.DoModal()==IDOK) 
	{
		exportObjName=requester.GetFileTitle();
		CSettingSheet expSheet;
		expSheet.SetTitle("Settings...");
		expSheet.SetActivePage(3);
		// Bring up the options requester and call the real procedure
		if(CallSettingSheet(expSheet)==IDOK)
			POVoutput(requester.GetPathName());
	};
}

void CSpilinEditorDoc::PovToClipboard(primitiva prim)
// export to clipboard the current previewed object
{
	//check there's something to export
	if(numnodi<3)
	{
		while (AfxMessageBox("No spline to export!",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
		return;
	};
	CString source,riga;
	BOOL SORwarn,SelfIntersect;
	float max;int ymax;
	CheckPovPrimitive(SORwarn,SelfIntersect,max,ymax);
	primitiva typeofobject=pGLView->objtype;
	// primitive validating
	/*	add this check when SOR support will be implemented
		if (exportObjType==SOR && SORwarn)
		{
			while (AfxMessageBox("The points order is not correct (from bottom to top of the window)\nor the curve is not legal for SOR primitive!\nUse LATHE or look at POV-Ray documentation.",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
			return;
		};*/
		if (SelfIntersect && (typeofobject==SOR || typeofobject==LATHE))
		{
			if (AfxMessageBox("Some segments extends to the left of the rotation axis.\nPerhaps there will be rendering errors!\nContine ?",MB_YESNO | MB_ICONEXCLAMATION) ==IDNO) return; 
		};
		if (typeofobject==PRISM && !chiusa)
		{
			while (AfxMessageBox("   PRISM primitive needs a closed curve!",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
			return;
		};
	// write header and beginning of primitive declaration
		source="#declare ";
		source+=exportObjName;
		source+=" = \n";
		switch (typeofobject)
		{
		case LATHE: source+="lathe{\n\tcubic_spline\n";
					break;
		case PRISM: source+="prism{\n";
					if (exportConic) source+="\tconic_sweep\n";
					riga.Format("\tcubic_spline\n\t0,\n\t%f,\n",exportHeight);
					source+=riga;
					break;
		case SOR: source+="sor{\n";
					break;
		}
	// writes number of nodes
		if(chiusa) riga.Format("\t%d,\n",numnodi+3);
		else riga.Format("\t%d,\n",numnodi);
		source+=riga;
		nodo* pnod=listaprimo;
		if(!proportional)
		{
			while (pnod!=NULL)
			{
		//	writes normalized nodes coordinates
			riga.Format("\t<%f,%f>",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
			source+=riga;
			pnod=pnod->succ;
			if (chiusa) source+=",\n";
			else if (pnod!=NULL) source+=",\n";
				else source+="\n";
			};
			if(chiusa)
			{
				pnod=listaprimo;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				source+=riga;
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				source+=riga;
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				source+=riga;
			};
		}
		else
		{
			float fact=float(cmapfactor)/1000;
			while (pnod!=NULL)
			{
		//	writes proportional nodes coordinates
			riga.Format("\t<%f,%f>",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
			source+=riga;
			pnod=pnod->succ;
			if (chiusa) source+=",\n";
			else if (pnod!=NULL) source+=",\n";
				else source+="\n";
			};
			if(chiusa)
			{
				pnod=listaprimo;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				source+=riga;
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				source+=riga;
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				source+=riga;
			};
		};
	// writes end of primitive declaration and of file
		if (typeofobject!=LATHE)	source+="//\topen\t// uncomment to make open\n//\tsturm\t// uncomment to activate sturmian root solver\n";
		source+="}\n";
	//qui va la generazione dell'oggetto come in POVOutput (ridirezionata in source)
	// usare csource += "testo da concatenare"
	// creare l'oggetto con tutte le opzioni attivate (sturm, open) e con valori di default
	//normalizzare ?
	if(::OpenClipboard(NULL))
	{
			HGLOBAL clipbuffer;
			char * buffer;
			::EmptyClipboard();
			clipbuffer = ::GlobalAlloc(GMEM_DDESHARE, source.GetLength()+1);
			buffer = (char*)::GlobalLock(clipbuffer);
			strcpy(buffer, LPCSTR(source));
			::GlobalUnlock(clipbuffer);
			::SetClipboardData(CF_TEXT,clipbuffer);
			::CloseClipboard();
		}
}

void CSpilinEditorDoc::POVoutput(CString FileName)
{
	if(numnodi<3)
	{
		while (AfxMessageBox("No spline to export!",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
		return;
	};
	BOOL SORwarn,SelfIntersect;
	float max;int ymax;
	CheckPovPrimitive(SORwarn,SelfIntersect,max,ymax);
	// primitive validating
		if (exportObjType==SOR && SORwarn)
		{
			while (AfxMessageBox("The points order is not correct (from bottom to top of the window)\nor the curve is not legal for SOR primitive!\nUse LATHE or look at POV-Ray documentation.",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
			return;
		};
		if (SelfIntersect && (exportObjType==SOR || exportObjType==LATHE))
		{
			if (AfxMessageBox("Some segments extends to the left of the rotation axis.\nPerhaps there will be rendering errors!\nContine ?",MB_YESNO | MB_ICONEXCLAMATION) ==IDNO) return; 
		};
		if (exportObjType==PRISM && !chiusa)
		{
			while (AfxMessageBox("   PRISM primitive needs a closed curve!",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
			return;
		};
	// open output file
		CStdioFile textfile;
		try
		{
		textfile.Open(FileName, CFile::modeCreate | CFile::modeWrite | CFile::typeText );
		}
		catch( CFileException* e )
		{
		#ifdef _DEBUG
		afxDump << "I can't open the file :" << e->m_cause << "\n";
		#endif
		e->Delete();
		}
	// write header and beginning of primitive declaration
		CString riga;
		textfile.WriteString("// File generated by SpilinEditor v1.2\n// POV-Ray v3.0 syntax\n#declare ");
		textfile.WriteString(exportObjName);
		textfile.WriteString(" = \n");
		switch (exportObjType)
		{
		case LATHE: textfile.WriteString("lathe{\n\tcubic_spline\n");
					break;
		case PRISM: textfile.WriteString("prism{\n");
					if (exportConic) textfile.WriteString("\tconic_sweep\n");
					riga.Format("\tcubic_spline\n\t0,\n\t%f,\n",exportHeight);
					textfile.WriteString(riga);
					break;
		case SOR: textfile.WriteString("sor{\n");
					break;
		}
	// writes number of nodes
		if(chiusa) riga.Format("\t%d,\n",numnodi+3);
		else riga.Format("\t%d,\n",numnodi);
		textfile.WriteString(riga);
		nodo* pnod=listaprimo;
		if(!proportional)
		{
			while (pnod!=NULL)
			{
		//	writes normalized nodes coordinates
				riga.Format("\t<%f,%f>",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				if (chiusa) textfile.WriteString(",\n");
				else if (pnod!=NULL) textfile.WriteString(",\n");
					else textfile.WriteString("\n");
			};
			if(chiusa)
			{
				pnod=listaprimo;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>\n",float(pnod->pun.x)/max,float(ymax-pnod->pun.y)/max);
				textfile.WriteString(riga);
			};
		}
		else
		{
			float fact=float(cmapfactor)/1000;
			while (pnod!=NULL)
			{
		//	writes proportional nodes coordinates
				riga.Format("\t<%f,%f>",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				if (chiusa) textfile.WriteString(",\n");
				else if (pnod!=NULL) textfile.WriteString(",\n");
					else textfile.WriteString("\n");
			};
			if(chiusa)
			{
				pnod=listaprimo;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>,\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				textfile.WriteString(riga);
				pnod=pnod->succ;
				riga.Format("\t<%f,%f>\n",float(pnod->pun.x)*fact,float(pnod->pun.y)*fact);
				textfile.WriteString(riga);
			};
		};
	// writes end of primitive declaration and of file
		if (exportObjType!=LATHE)
		{
			if (exportOpen) textfile.WriteString("\topen\n");
			if (exportSturm) textfile.WriteString("\tsturm\n");
		};
		textfile.WriteString("}\n// end of file");
}

void CSpilinEditorDoc::sostnodo(CPoint punto)
{
	if (corr!=NULL)
	{
		// x clamping to positive values
		Clamping(punto);
		corr->pun=punto;
		CheckPoint();
		SetModifiedFlag();
		UpdateAllViews(NULL);
	};
}

BOOLEAN CSpilinEditorDoc::pickcorrel(CPoint punto)
{
	// separare i casi numnodi pari e dispari 
	// nel caso pari occorre prescandire un punto
	// scansione  dall'inizio e dal fondo fino al centro
	if (numnodi>0)
	{
		BOOLEAN flag=FALSE;
		int dx=0;int dy=0;
		nodo *punti=listaprimo;
		nodo *puntf=listaultimo;
		while(punti!=NULL && puntf!=NULL && !flag)
		{
			dx=abs(punti->pun.x-punto.x);
			dy=abs(punti->pun.y-punto.y);
			if (dx<4 && dy<4) {corr=punti;flag=TRUE;}
			else
			{
				dx=abs(puntf->pun.x-punto.x);
				dy=abs(puntf->pun.y-punto.y);
				if (dx<4 && dy<4) {corr=puntf;flag=TRUE;};
			};
			punti=punti->succ;
			puntf=puntf->prec;
		};
		return flag;
	}
	return FALSE;
}

void CSpilinEditorDoc::OnFileEsportainvrml20() 
{
	// codice per file-requester
	static char  Filter[] = "VRML Files (*.wrl)|*.wrl|All Files (*.*)|*.*||";
	CFileDialog requester(FALSE,"wrl","untitled",OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR,Filter);
	requester.m_ofn.lpstrTitle="VRML 2.0 Export";
	if (requester.DoModal()==IDOK) 
	{
		// chiama routine di options-dialog e scrittura su file
		VRMLoutput(requester.GetPathName(),requester.GetFileTitle());
	};
}

void CSpilinEditorDoc::VRMLoutput(CString FileName,CString nomogg)
{
	VrmlExpDlg vreq;
	vreq.m_sez=16;
	vreq.m_splstep=6;
	vreq.m_shininess=0.3f;
	vreq.m_transparency=0.0f;
	vreq.m_crease=30;
	vreq.m_radius=0;
	vreq.m_verso=pviewnormflip;
	if (vreq.DoModal()==IDOK && numnodi>0)
	{
	// decisione del verso, calcolo baricentro e fattore normalizzazione
	nodo* pnod=listaprimo;
	int term1=(listaprimo->succ->succ->pun.x-listaprimo->succ->pun.x)*(listaprimo->succ->succ->succ->pun.y-listaprimo->succ->pun.y);
	int term2=(listaprimo->succ->succ->succ->pun.x-listaprimo->succ->succ->pun.x)*(listaprimo->succ->succ->pun.y-listaprimo->succ->pun.y);
	BOOLEAN antiorario=FALSE;
	if (vreq.m_verso ^ (term1-term2 < 0) ) antiorario=TRUE; 
	int xmin,xmax,ymin,ymax;
	xmax=ymax=0;
	xmin=ymin=INT_MAX;
	while (pnod!=NULL)
	{
		if(pnod->pun.x>xmax) xmax=pnod->pun.x;
		if(pnod->pun.y>ymax) ymax=pnod->pun.y;
		if(pnod->pun.x<xmin) xmin=pnod->pun.x;
		if(pnod->pun.y<ymin) ymin=pnod->pun.y;
		pnod=pnod->succ;
	};
	float xcentro=float(xmin)+float(xmax-xmin)/2.0f;
	float ycentro=float(ymin)+float(ymax-ymin)/2.0f;
	float max= (xmax-xmin)>(ymax-ymin)?float((xmax-xmin)/10):float((ymax-ymin)/10);
	// apri file completo di estensione
	CStdioFile textfile;
	try
	{
	textfile.Open(FileName, CFile::modeCreate | CFile::modeWrite | CFile::typeText );
	}
	catch( CFileException* e )
	{
	#ifdef _DEBUG
	afxDump << "Can't open file :" << e->m_cause << "\n";
	#endif
	e->Delete();
	}
// qui va generato il file in formato vrml 2
// intestazione e inizio primitiva
	textfile.WriteString("#VRML V2.0 utf8\n# File generated by SpilinEditor v1.1\n# VRML 2.0 syntax\n\n");
	textfile.WriteString("DEF ");
	textfile.WriteString(nomogg);
	textfile.WriteString(" Shape {\n\tgeometry Extrusion {\n\t\tcrossSection[\n");
	
	CString riga;
	float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
	nodo *vpunt[4];
	delta=float(1./vreq.m_splstep);
	if (antiorario)	{vpunt[0]=listaprimo;
					vpunt[1]=vpunt[0]->succ;
					vpunt[2]=vpunt[1]->succ;
					vpunt[3]=vpunt[2]->succ;}
	else {vpunt[0]=listaultimo;
		vpunt[1]=vpunt[0]->prec;
		vpunt[2]=vpunt[1]->prec;
		vpunt[3]=vpunt[2]->prec;};	
	BOOL warn=(vpunt[1]->pun.x<0 || vpunt[1]->pun.y<0);
	if (numnodi>=4)
	{
		riga.Format("\t\t\t%f %f,\n",(float(vpunt[1]->pun.x)-xcentro)/max,(float(vpunt[1]->pun.y)-ycentro)/max);
		textfile.WriteString(riga);
		while (vpunt[3]!=NULL)
		{
			ax=.5f*float((-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
			bx=.5f*float((2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
			cx=.5f*float((-vpunt[0]->pun.x+vpunt[2]->pun.x));
			
			ay=.5f*float((-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
			by=.5f*float((2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
			cy=.5f*float((-vpunt[0]->pun.y+vpunt[2]->pun.y));
		
			x=float(vpunt[1]->pun.x);
			dex=delta*(delta*(delta*ax+bx)+cx*delta);
			de2x=delta*delta*(delta*6*ax+2*bx);
			de3x=6*ax*delta*delta*delta;
			
			y=float(vpunt[1]->pun.y);
			dey=delta*(delta*(delta*ay+by)+cy*delta);
			de2y=delta*delta*(delta*6*ay+2*by);
			de3y=6*ay*delta*delta*delta;
			
			for(int j=1;j<=vreq.m_splstep;j++)
			{
				x+=dex;
				dex+=de2x;
				de2x+=de3x;
				y+=dey;
				dey+=de2y;
				de2y+=de3y;
				warn|=(x<0 || y<0);
				riga.Format("\t\t\t%f %f,\n",(x-xcentro)/max,(y-ycentro)/max);
				textfile.WriteString(riga);
			};
			if (antiorario)	{vpunt[0]=vpunt[0]->succ;
							vpunt[1]=vpunt[0]->succ;
							vpunt[2]=vpunt[1]->succ;
							vpunt[3]=vpunt[2]->succ;}
			else {vpunt[0]=vpunt[0]->prec;
				vpunt[1]=vpunt[0]->prec;
				vpunt[2]=vpunt[1]->prec;
				vpunt[3]=vpunt[2]->prec;};
		};
	};
	//scrivi il percorso di rivoluzione
	textfile.WriteString("\n\t\t]\n\t\tspine [\n");
	double deltang=2*3.1415926535/double(vreq.m_sez);
	float raggio;
	if (vreq.m_radius==0) raggio=xcentro/max;
	else raggio=(float(vreq.m_radius)+xcentro)/max;
	
	for (int s=0;s<=vreq.m_sez-1;s++)
	{
		riga.Format("\t\t\t%f 0.0 %f,\n",raggio*cos(s*deltang),raggio*sin(s*deltang));
		textfile.WriteString(riga);
	};
	riga.Format("\t\t\t%f 0.0 %f]\n",raggio*cos(0.0),raggio*sin(0.0));
	textfile.WriteString(riga);
	textfile.WriteString("\t\tbeginCap FALSE\n\t\tendCap FALSE\n\t\tcreaseAngle ");
	riga.Format("%f",vreq.m_crease/90.0f);
	textfile.WriteString(riga);

	// parametri del materiale : colore diffuso..
		textfile.WriteString("\n\t}\n\tappearance Appearance{\n\t\t\tmaterial Material{\n\t\t\tdiffuseColor ");
		riga.Format("%f %f %f",GetRValue(vreq.diffusec)/255.0f,GetGValue(vreq.diffusec)/255.0f,GetBValue(vreq.diffusec)/255.0f);
		textfile.WriteString(riga);
	/* ..colore ambiente..
		textfile.WriteString("\n\t\t\tambientColor ");
		riga.Format("%f %f %f",GetRValue(vreq.ambientc)/255.0f,GetGValue(vreq.ambientc)/255.0f,GetBValue(vreq.ambientc)/255.0f);
		textfile.WriteString(riga);*/
	// ..colore emesso..
		textfile.WriteString("\n\t\t\temissiveColor ");
		riga.Format("%f %f %f",GetRValue(vreq.emittedc)/255.0f,GetGValue(vreq.emittedc)/255.0f,GetBValue(vreq.emittedc)/255.0f);
		textfile.WriteString(riga);
	// ..lucentezza e colore speculare..
		if (vreq.m_shininess>0)
		{
			textfile.WriteString("\n\t\t\tshininess ");
			riga.Format("%f",vreq.m_shininess);
			textfile.WriteString(riga);
			textfile.WriteString("\n\t\t\tspecularColor ");
			riga.Format("%f %f %f",GetRValue(vreq.specularc)/255.0f,GetGValue(vreq.specularc)/255.0f,GetBValue(vreq.specularc)/255.0f);
			textfile.WriteString(riga);
		}
	// ..trasparenza
		if (vreq.m_transparency>0)
		{
			textfile.WriteString("\n\t\t\ttransparency ");
			riga.Format("%f",vreq.m_transparency);
			textfile.WriteString(riga);
		}

		textfile.WriteString("\n\t\t}\n\t}\n}\n# fine del file");
		if (warn) while (AfxMessageBox("Some segments extends to the left of the rotation axis.\nPerhaps there will be anomalies in the object!",MB_OK | MB_ICONEXCLAMATION) !=IDOK); 
	};
}

CPoint CSpilinEditorDoc::NextPunto()
{
	CPoint risult(-5,-5);
	if (numnodi!=0)
	{
		if(corr==NULL) corr=listaprimo;
		else corr=corr->succ;
		if(corr!=NULL) risult=corr->pun;
	};
	return risult;
}
/*----------------  OLD CODE keep for safety -----------------------
char CSpilinEditorDoc::genExtrusion()
{
	if (chiusa)
	{
////// vertices generation
// memory allocation
		int puntisez=1+numnodi*numstepspreview;
		double** solido;
		int i,n;
		solido=new double*[puntisez];
		if (!solido) 
			{while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
			return 1;};
		for (i=0;i<puntisez;i++)
		{
			solido[i]=new double[3];
			if (!solido[i]){while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
							return 1;};
		};
		// decide normals orientation (based on the first 2 spline segments)
		i=(listaprimo->succ->pun.x-listaprimo->pun.x)*(listaprimo->succ->succ->pun.y-listaprimo->succ->pun.y);
		n=(listaprimo->succ->succ->pun.x-listaprimo->succ->pun.x)*(listaprimo->succ->pun.y-listaprimo->pun.y);
		BOOL antiorario=TRUE;
		if (pviewnormflip ^ (i-n < 0) ) antiorario=FALSE; 
		//compute "mass center" and normalization factor
		nodo* pnod=listaprimo;
		int xmin,ymin,xmax,ymax;
		xmax=ymax=0;
		xmin=ymin=INT_MAX;
		while (pnod!=NULL)
		{
			if(pnod->pun.x>xmax) xmax=pnod->pun.x;
			if(pnod->pun.y>ymax) ymax=pnod->pun.y;
			if(pnod->pun.x<xmin) xmin=pnod->pun.x;
			if(pnod->pun.y<ymin) ymin=pnod->pun.y;
			pnod=pnod->succ;
		};
		double xcentro=double(xmin)+double(xmax-xmin)/2.0;
		double ycentro=double(ymin)+double(ymax-ymin)/2.0;
		double max=(xmax-xmin)>(ymax-ymin)?double(xmax-xmin):double(ymax-ymin);
		// generation of point mesh
		double ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
		nodo *vpunt[4];
		delta=double(1./numstepspreview);
		if (antiorario)	{vpunt[0]=listaprimo;
						vpunt[1]=vpunt[0]->succ;
						vpunt[2]=vpunt[1]->succ;
						if (numnodi==3) vpunt[3]=vpunt[0];
						else vpunt[3]=vpunt[2]->succ;}
		else {vpunt[0]=listaultimo;
			vpunt[1]=vpunt[0]->prec;
			vpunt[2]=vpunt[1]->prec;
			if (numnodi==3) vpunt[3]=vpunt[0];
			else vpunt[3]=vpunt[2]->prec;};	
		solido[0][0]=( double(vpunt[1]->pun.x)-xcentro )/max;
		solido[0][1]=( -double(vpunt[1]->pun.y)+ycentro )/max;
		solido[0][2]=0.0;
		n=1;
		do{
			ax=double(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
			bx=double(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
			cx=double(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
			
			ay=double(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
			by=double(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
			cy=double(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
		
			x=double(vpunt[1]->pun.x);
				dex=((ax*delta+bx)*delta+cx)*delta;
				de2x=(6*ax*delta+2*bx)*delta*delta;
				de3x=6*ax*delta*delta*delta;
				
			y=double(vpunt[1]->pun.y);
				dey=((ay*delta+by)*delta+cy)*delta;
				de2y=(6*ay*delta+2*by)*delta*delta;
				de3y=6*ay*delta*delta*delta;
			
			for(int j=1;j<=numstepspreview;j++)
			{
				x+=dex;
				dex+=de2x;
				de2x+=de3x;
				y+=dey;
				dey+=de2y;
				de2y+=de3y;
				solido[n][0]=( x-xcentro )/max;
				solido[n][1]=( -y+ycentro )/max;
				solido[n][2]=0.0;
				n++;
			};
			if(antiorario)
			{
				vpunt[0]=vpunt[0]->succ!=NULL ? vpunt[0]->succ : listaprimo;
				vpunt[1]=vpunt[1]->succ!=NULL ? vpunt[1]->succ : listaprimo;
				vpunt[2]=vpunt[2]->succ!=NULL ? vpunt[2]->succ : listaprimo;
				vpunt[3]=vpunt[3]->succ!=NULL ? vpunt[3]->succ : listaprimo;
			}
			else{
				vpunt[0]=vpunt[0]->prec!=NULL ? vpunt[0]->prec : listaultimo;
				vpunt[1]=vpunt[1]->prec!=NULL ? vpunt[1]->prec : listaultimo;
				vpunt[2]=vpunt[2]->prec!=NULL ? vpunt[2]->prec : listaultimo;
				vpunt[3]=vpunt[3]->prec!=NULL ? vpunt[3]->prec : listaultimo;
			};
		}
		while ((antiorario && vpunt[0]!=listaprimo) || (!antiorario && vpunt[0]!=listaultimo) );
////generation of normals
		double** normali;
		normali=new double*[puntisez-1];
		if (!normali) 
			{while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
			return 1;};
		for (n=0;n<puntisez-1;n++)
		{
			normali[n]=new double[2];
			double px=-(solido[n+1][1]-solido[n][1]);
			double py=(solido[n+1][0]-solido[n][0]);
			double lung=1.0/sqrt(px*px+py*py);
			normali[n][0]=px*lung;
			normali[n][1]=py*lung;
		};
		double hemiHeight=pviewHeight/2.0;
		if(garbagelist!=NULL) DeleteGarbage();
	////// creation of display-list
		
		GLUtesselator* tess=gluNewTess();
		gluTessCallback(tess, GLU_TESS_ERROR, (void (CALLBACK*)()) &errorCallback);
		gluTessCallback(tess, GLU_TESS_BEGIN, (void (CALLBACK*)()) &beginCallback ); 
		gluTessCallback(tess, GLU_TESS_VERTEX, (void (CALLBACK*)()) &vertexCallback ); 
		gluTessCallback(tess, GLU_TESS_COMBINE, (void (CALLBACK*)()) &combineCallback);
		gluTessCallback(tess, GLU_TESS_END, (void (CALLBACK*)()) &endCallback);
		gluTessProperty(tess,GLU_TESS_WINDING_RULE,GLU_TESS_WINDING_ODD);
		gluTessProperty(tess,GLU_TESS_BOUNDARY_ONLY,GL_FALSE);

		if(Esidedisplist==0) Esidedisplist=glGenLists(1);
		glNewList(Esidedisplist,GL_COMPILE);
			gluTessBeginPolygon(tess, NULL);
				gluTessBeginContour(tess);
				for (n=0;n<puntisez;n++)
				{
					solido[n][2]=hemiHeight;
					gluTessVertex(tess,solido[n],solido[n]);
				};
				gluTessEndContour(tess);
			gluTessEndPolygon(tess);
		glEndList();

		gluDeleteTess(tess);

		if(Edisplist==0) Edisplist=glGenLists(1);
		glNewList(Edisplist,GL_COMPILE);
			glBegin(GL_QUAD_STRIP);
				for (n=0;n<puntisez-1;n++)
				{
					glNormal3d(normali[n][0],normali[n][1],0.0);
					glVertex3d(solido[n][0],solido[n][1],-hemiHeight);
					glVertex3d(solido[n][0],solido[n][1],hemiHeight);
				};
				glNormal3d(normali[0][0],normali[0][1],0.0);
				glVertex3d(solido[0][0],solido[0][1],-hemiHeight);
				glVertex3d(solido[0][0],solido[0][1],hemiHeight);
			glEnd();
			glFrontFace(GL_CW);
			glNormal3d(0.0, 0.0, 1.0);
			glCallList(Esidedisplist);
			glPushMatrix();
			glTranslated(0.0, 0.0, -2*hemiHeight);
			glFrontFace(GL_CCW);
			glNormal3f(0.0, 0.0, -1.0);
			glCallList(Esidedisplist);
			glPopMatrix();
		glEndList();
		// memory cleanup
		for (i=0;i<puntisez-1;i++) {delete[] solido[i];delete[] normali[i];};
		delete[] solido[puntisez-1];
		delete[] solido;
		delete[] normali;
		return 0;
	};
	return 1;
}
//*/
char CSpilinEditorDoc::genExtrusion() // new code (is faster and use less memory)
{
	if (chiusa)
	{
////// vertices generation
// memory allocation
		int puntisez=numnodi*numstepspreview;
		double** solido;
		int i,n;
		solido=new double*[puntisez];
		if (!solido) 
			{while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
			return 1;};
		for (i=0;i<puntisez;i++)
		{
			solido[i]=new double[3];
			if (!solido[i]){while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
							return 1;};
		};
		// decide normals orientation (based on the first 2 spline segments)
		BOOL ccwise;
		i=(listaprimo->succ->pun.x-listaprimo->pun.x)*(listaprimo->succ->succ->pun.y-listaprimo->succ->pun.y);
		n=(listaprimo->succ->succ->pun.x-listaprimo->succ->pun.x)*(listaprimo->succ->pun.y-listaprimo->pun.y);
		if (pviewnormflip ^ (i-n < 0) ) ccwise=FALSE; 
		else ccwise=TRUE;
		//compute "mass center" and normalization factor
		nodo* pnod=listaprimo;
		int xmin,ymin,xmax,ymax;
		xmax=ymax=0;
		xmin=ymin=INT_MAX;
		while (pnod!=NULL)
		{
			if(pnod->pun.x>xmax) xmax=pnod->pun.x;
			if(pnod->pun.y>ymax) ymax=pnod->pun.y;
			if(pnod->pun.x<xmin) xmin=pnod->pun.x;
			if(pnod->pun.y<ymin) ymin=pnod->pun.y;
			pnod=pnod->succ;
		};
		double xcentro=double(xmin)+double(xmax-xmin)/2.0;
		double ycentro=double(ymin)+double(ymax-ymin)/2.0;
		double max=(xmax-xmin)>(ymax-ymin)?double(xmax-xmin):double(ymax-ymin);
//compute hemiheight and release memory	previously allocated by the tesselator
		double hemiHeight=pviewHeight/2.0;
		if(garbagelist!=NULL) DeleteGarbage();
////// generation of point mesh
// creation of display-list
		GLUtesselator* tess=gluNewTess();
		gluTessCallback(tess, GLU_TESS_ERROR, (void (CALLBACK*)()) &errorCallback);
		gluTessCallback(tess, GLU_TESS_BEGIN, (void (CALLBACK*)()) &beginCallback ); 
		gluTessCallback(tess, GLU_TESS_VERTEX, (void (CALLBACK*)()) &vertexCallback ); 
		gluTessCallback(tess, GLU_TESS_COMBINE, (void (CALLBACK*)()) &combineCallback);
		gluTessCallback(tess, GLU_TESS_END, (void (CALLBACK*)()) &endCallback);
		gluTessProperty(tess,GLU_TESS_WINDING_RULE,GLU_TESS_WINDING_ODD);
		gluTessProperty(tess,GLU_TESS_BOUNDARY_ONLY,GL_FALSE);

		if(Esidedisplist==0) Esidedisplist=glGenLists(1);
		glNewList(Esidedisplist,GL_COMPILE);
			gluTessBeginPolygon(tess, NULL);
				gluTessBeginContour(tess);
				double ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
				nodo *vpunt[4];
				delta=double(1./numstepspreview);
				vpunt[0]=listaprimo;
				vpunt[1]=vpunt[0]->succ;
				vpunt[2]=vpunt[1]->succ;
				if (numnodi==3) vpunt[3]=vpunt[0];
				else vpunt[3]=vpunt[2]->succ;
				n=0;
				do{
					ax=double(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
					bx=double(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
					cx=double(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
					
					ay=double(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
					by=double(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
					cy=double(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
				
					x=double(vpunt[1]->pun.x);
					dex=((ax*delta+bx)*delta+cx)*delta;
					de2x=(6*ax*delta+2*bx)*delta*delta;
					de3x=6*ax*delta*delta*delta;
						
					y=double(vpunt[1]->pun.y);
					dey=((ay*delta+by)*delta+cy)*delta;
					de2y=(6*ay*delta+2*by)*delta*delta;
					de3y=6*ay*delta*delta*delta;
					
					for(int j=1;j<=numstepspreview;j++)
					{
						solido[n][0]=( x-xcentro )/max;
						solido[n][1]=( -y+ycentro )/max;
						solido[n][2]=hemiHeight;
						gluTessVertex(tess,solido[n],solido[n]);
						x+=dex;
						dex+=de2x;
						de2x+=de3x;
						y+=dey;
						dey+=de2y;
						de2y+=de3y;
						n++;
					};
					vpunt[0]=vpunt[0]->succ!=NULL ? vpunt[0]->succ : listaprimo;
					vpunt[1]=vpunt[1]->succ!=NULL ? vpunt[1]->succ : listaprimo;
					vpunt[2]=vpunt[2]->succ!=NULL ? vpunt[2]->succ : listaprimo;
					vpunt[3]=vpunt[3]->succ!=NULL ? vpunt[3]->succ : listaprimo;
				}
				while (vpunt[0]!=listaprimo);
				gluTessEndContour(tess);
			gluTessEndPolygon(tess);
		glEndList();

		gluDeleteTess(tess);

		if(Edisplist==0) Edisplist=glGenLists(1);
		glNewList(Edisplist,GL_COMPILE);
			if(ccwise) glFrontFace(GL_CCW);
			else glFrontFace(GL_CW);
			glBegin(GL_QUAD_STRIP);
				double px,py,lung;
				for (n=0;n<puntisez;n++)
				{
					glVertex3d(solido[n][0],solido[n][1],-hemiHeight);
					glVertex3d(solido[n][0],solido[n][1],hemiHeight);
					px=-(solido[(n+1)%puntisez][1]-solido[n][1]);
					py=(solido[(n+1)%puntisez][0]-solido[n][0]);
					lung=1.0/sqrt(px*px+py*py);
					glNormal3d(px*lung,py*lung,0.0);
				};
				px=-(solido[1][1]-solido[0][1]);
				py=(solido[1][0]-solido[0][0]);
				lung=1.0/sqrt(px*px+py*py);
				glVertex3d(solido[0][0],solido[0][1],-hemiHeight);
				glVertex3d(solido[0][0],solido[0][1],hemiHeight);
				px=-(solido[1][1]-solido[0][1]);
				py=(solido[1][0]-solido[0][0]);
				lung=1.0/sqrt(px*px+py*py);
				glNormal3d(px*lung,py*lung,0.0);
			glEnd();
			if(!ccwise) glFrontFace(GL_CCW);
			else glFrontFace(GL_CW);
			glNormal3d(0.0, 0.0, 1.0);
			glCallList(Esidedisplist);
			glPushMatrix();
			glTranslated(0.0, 0.0, -2*hemiHeight);
			if(ccwise) glFrontFace(GL_CCW);
			else glFrontFace(GL_CW);
			glNormal3f(0.0, 0.0, -1.0);
			glCallList(Esidedisplist);
			glPopMatrix();
			glFrontFace(GL_CCW);
		glEndList();
		// memory cleanup
		for (i=0;i<puntisez;i++) delete[] solido[i];
		delete[] solido;
		return 0;
	};
	return 1;
}

char CSpilinEditorDoc::genRevolution()
{
if (numnodi>=3)
{
// Geometry generation (vertices coordinates)
	// memory allocation
	struct coor3d{float x;float y;float z; };
	coor3d** solido;
	int puntisez,n,i;
	if(!chiusa && numnodi>=4) puntisez=numnodi-2+(numnodi-3)*(numstepspreview-1);
	else puntisez=1+numnodi*numstepspreview;
	solido=new coor3d*[puntisez];
	if (!solido) 
		{while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
		return 1;};
	// Warning: if you run out of memory is a mess
	for (i=0;i<puntisez;i++)
	{
		solido[i]=new coor3d[sezsolido];
		if (!solido[i]){while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
						return 1;};
	};
	// calculate normals orientation
	BOOLEAN antiorario=FALSE;
	i=(listaprimo->succ->pun.x-listaprimo->pun.x)*(listaprimo->succ->succ->pun.y-listaprimo->succ->pun.y);
	n=(listaprimo->succ->succ->pun.x-listaprimo->succ->pun.x)*(listaprimo->succ->pun.y-listaprimo->pun.y);
	if (pviewnormflip ^ (i-n> 0) ) antiorario=TRUE; 
	
	// calculate "mass center" and normalization factor
	nodo* pnod=listaprimo->succ;
	int xmin,ymin,xmax,ymax;
	xmax=ymax=0;
	xmin=ymin=INT_MAX;
	while (pnod->succ!=NULL)
	{
		if(pnod->pun.x>xmax) xmax=pnod->pun.x;
		if(pnod->pun.y>ymax) ymax=pnod->pun.y;
		if(pnod->pun.x<xmin) xmin=pnod->pun.x;
		if(pnod->pun.y<ymin) ymin=pnod->pun.y;
		pnod=pnod->succ;
	};
	float ycentro=float(ymin+ymax)/2.0f;
	float max=xmax>(ymax-ymin)?float(xmax):float(ymax-ymin);
	// generation of vertices
	double deltang=2*3.1415926535/double(sezsolido);
	if(!chiusa && numnodi>=4) // open splines
	{
		for (int s=0;s<sezsolido;s++)
		{
			double scosine=cos(s*deltang);
			double ssine=sin(s*deltang);
			float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
			nodo *vpunt[4];
			delta=float(1./numstepspreview);
			if (antiorario)	{vpunt[0]=listaprimo;
							vpunt[1]=vpunt[0]->succ;
							vpunt[2]=vpunt[1]->succ;
							vpunt[3]=vpunt[2]->succ;}
			else {vpunt[0]=listaultimo;
				vpunt[1]=vpunt[0]->prec;
				vpunt[2]=vpunt[1]->prec;
				vpunt[3]=vpunt[2]->prec;};	
			solido[0][s].x=float(vpunt[1]->pun.x*scosine)/max;
			solido[0][s].y=float(vpunt[1]->pun.x*ssine)/max;
			solido[0][s].z=( float(vpunt[1]->pun.y)-ycentro )/max;
			n=1;
				while (vpunt[3]!=NULL)
				{
					ax=float(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
					bx=float(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
					cx=float(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
					
					ay=float(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
					by=float(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
					cy=float(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
				
					x=float(vpunt[1]->pun.x);
					dex=((ax*delta+bx)*delta+cx)*delta;
					de2x=(6*ax*delta+2*bx)*delta*delta;
					de3x=6*ax*delta*delta*delta;
					
					y=float(vpunt[1]->pun.y);
					dey=((ay*delta+by)*delta+cy)*delta;
					de2y=(6*ay*delta+2*by)*delta*delta;
					de3y=6*ay*delta*delta*delta;
					
					for(int j=1;j<=numstepspreview;j++)
					{
						x+=dex;
						dex+=de2x;
						de2x+=de3x;
						y+=dey;
						dey+=de2y;
						de2y+=de3y;
						solido[n][s].x=x*float(scosine)/max;
						solido[n][s].y=x*float(ssine)/max;
						solido[n][s].z=(y-ycentro)/max;
						n++;
					};
					if (antiorario)	{vpunt[0]=vpunt[0]->succ;
									vpunt[1]=vpunt[0]->succ;
									vpunt[2]=vpunt[1]->succ;
									vpunt[3]=vpunt[2]->succ;}
					else {vpunt[0]=vpunt[0]->prec;
						vpunt[1]=vpunt[0]->prec;
						vpunt[2]=vpunt[1]->prec;
						vpunt[3]=vpunt[2]->prec;};
				};
		};
	};
	if(chiusa) //closed splines
	{
		for (int s=0;s<sezsolido;s++)
		{
			double scosine=cos(s*deltang);
			double ssine=sin(s*deltang);
			float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
			nodo *vpunt[4];
			delta=float(1./numstepspreview);
			if (antiorario)
			{
				vpunt[0]=listaprimo;
				vpunt[1]=vpunt[0]->succ;
				vpunt[2]=vpunt[1]->succ;
				if (numnodi==3) vpunt[3]=vpunt[0];
				else vpunt[3]=vpunt[2]->succ;
			}
			else{
				vpunt[0]=listaultimo;
				vpunt[1]=vpunt[0]->prec;
				vpunt[2]=vpunt[1]->prec;
				if (numnodi==3) vpunt[3]=vpunt[0];
				else vpunt[3]=vpunt[2]->prec;
			};
			solido[0][s].x=float(vpunt[1]->pun.x*scosine)/max;
			solido[0][s].y=float(vpunt[1]->pun.x*ssine)/max;
			solido[0][s].z=( float(vpunt[1]->pun.y)-ycentro )/max;
			n=1;
			do{
				ax=.5f*float((-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
				bx=.5f*float((2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
				cx=.5f*float((-vpunt[0]->pun.x+vpunt[2]->pun.x));
				
				ay=.5f*float((-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
				by=.5f*float((2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
				cy=.5f*float((-vpunt[0]->pun.y+vpunt[2]->pun.y));
			
				x=float(vpunt[1]->pun.x);
				dex=((ax*delta+bx)*delta+cx)*delta;
				de2x=(6*ax*delta+2*bx)*delta*delta;
				de3x=6*ax*delta*delta*delta;
				
				y=float(vpunt[1]->pun.y);
				dey=((ay*delta+by)*delta+cy)*delta;
				de2y=(6*ay*delta+2*by)*delta*delta;
				de3y=6*ay*delta*delta*delta;
				
				for(int j=1;j<=numstepspreview;j++)
				{
					x+=dex;
					dex+=de2x;
					de2x+=de3x;
					y+=dey;
					dey+=de2y;
					de2y+=de3y;
					solido[n][s].x=x*float(scosine)/max;
					solido[n][s].y=x*float(ssine)/max;
					solido[n][s].z=(y-ycentro)/max;
					n++;
				};
				if(antiorario)
				{
					vpunt[0]=vpunt[0]->succ!=NULL ? vpunt[0]->succ : listaprimo;
					vpunt[1]=vpunt[1]->succ!=NULL ? vpunt[1]->succ : listaprimo;
					vpunt[2]=vpunt[2]->succ!=NULL ? vpunt[2]->succ : listaprimo;
					vpunt[3]=vpunt[3]->succ!=NULL ? vpunt[3]->succ : listaprimo;
				}
				else{
					vpunt[0]=vpunt[0]->prec!=NULL ? vpunt[0]->prec : listaultimo;
					vpunt[1]=vpunt[1]->prec!=NULL ? vpunt[1]->prec : listaultimo;
					vpunt[2]=vpunt[2]->prec!=NULL ? vpunt[2]->prec : listaultimo;
					vpunt[3]=vpunt[3]->prec!=NULL ? vpunt[3]->prec : listaultimo;
				};
			}
			while ((antiorario && vpunt[0]!=listaprimo) || (!antiorario && vpunt[0]!=listaultimo) );
		};
	};
////// generation of normals
	//  memory allocation
	coor3d** normali;
	normali=new coor3d*[puntisez];
	if (!normali) 
		{while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
		return 1;};
	for (i=0;i<puntisez;i++)
	{
		normali[i]=new coor3d[sezsolido];
		if (!normali[i]){while (AfxMessageBox("   Insufficient Memory for Preview!",MB_OK | MB_ICONEXCLAMATION) !=IDOK);
						return 1;};
	};
	//  normals generation
	for (n=0;n<puntisez-1;n++)
		for (int s=0;s<sezsolido;s++)
		{
			float x1=solido[n+1][s].x-solido[n][s].x;
			float y1=solido[n+1][s].y-solido[n][s].y;
			float z1=solido[n+1][s].z-solido[n][s].z;
			
			float x2=solido[n][(s+1)%sezsolido].x-solido[n][s].x;
			float y2=solido[n][(s+1)%sezsolido].y-solido[n][s].y;
			float z2=solido[n][(s+1)%sezsolido].z-solido[n][s].z;

			normali[n][s].x=-y1*z2+y2*z1;
			normali[n][s].y=x1*z2-x2*z1;
			normali[n][s].z=-x1*y2+x2*y1;
			
			// calculate normal lenght
			x2=1.f/float(sqrt(normali[n][s].x*normali[n][s].x+normali[n][s].y*normali[n][s].y+normali[n][s].z*normali[n][s].z));
			normali[n][s].x*=x2;
			normali[n][s].y*=x2;
			normali[n][s].z*=x2;
		};
	// strange case normal=0 for the first vertex of every sect.
	if (normali[0][0].x==0 && normali[0][0].y==0 && normali[0][0].z==0)
		for (int s=0;s<sezsolido;s++) normali[0][s]=normali[1][s];
	// calculate normal for last vertices
	for (int s=0;s<sezsolido;s++) normali[puntisez-1][s]=chiusa?normali[0][s]:normali[puntisez-2][s];
	// display-list generation
	// using horizontal stripes
	if(Rdisplist==0) Rdisplist=glGenLists(1);
	glNewList(Rdisplist,GL_COMPILE);
		for (i=0;i<puntisez-1;i++)
		{
			glBegin(GL_QUAD_STRIP);
			for (int s=0;s<sezsolido;s++)
			{
				glVertex3f(solido[i][s].x,solido[i][s].y,-solido[i][s].z);
				glNormal3f(normali[i][s].x,normali[i][s].y,-normali[i][s].z);
				glVertex3f(solido[i+1][s].x,solido[i+1][s].y,-solido[i+1][s].z);
				glNormal3f(normali[i+1][s].x,normali[i+1][s].y,-normali[i+1][s].z);
			};
			glVertex3f(solido[i][0].x,solido[i][0].y,-solido[i][0].z);
			glNormal3f(normali[i][0].x,normali[i][0].y,-normali[i][0].z);
			glVertex3f(solido[i+1][0].x,solido[i+1][0].y,-solido[i+1][0].z);
			glNormal3f(normali[i+1][0].x,normali[i+1][0].y,-normali[i+1][0].z);
			glEnd();
		};
	glEndList();
//cancellazione strutture di appoggio
	for (i=0;i<puntisez;i++) {delete[] solido[i];delete[] normali[i];};
	delete[] solido;
	delete[] normali;
	return 0;
};
return 1;
}

BOOL CSpilinEditorDoc::Dist(CPoint p1,CPoint p2,CPoint p3,float soglia)
{
	float p1p2=(float)sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));
	float p1p3=(float)sqrt((p3.x-p1.x)*(p3.x-p1.x)+(p3.y-p1.y)*(p3.y-p1.y));
	float p2p3=(float)sqrt((p3.x-p2.x)*(p3.x-p2.x)+(p3.y-p2.y)*(p3.y-p2.y));
	if (p1p2 > p1p3 && p1p2 > p2p3)
	{
		float A1=p1p2*p1p2*soglia*soglia*.25f;
		float A2=(p1p2+p1p3+p2p3)*(p1p2+p1p3-p2p3)*(p1p2-p1p3+p2p3)*(-p1p2+p1p3+p2p3)/16;
		return A2<=A1;
	};
	/* old method keep for safety
	BOOL cond1=p3.x>=++p1.x && p3.x<=--p2.x || p3.x<=++p1.x && p3.x>=--p2.x;
	BOOL cond2=p3.y>=++p1.y && p3.y<=--p2.y || p3.y<=--p1.y && p3.y>=++p2.y;
	if (cond1 && cond2)
	{
		float p1p2=(float)sqrt((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));
		float p1p3=(float)sqrt((p3.x-p1.x)*(p3.x-p1.x)+(p3.y-p1.y)*(p3.y-p1.y));
		float p2p3=(float)sqrt((p3.x-p2.x)*(p3.x-p2.x)+(p3.y-p2.y)*(p3.y-p2.y));
		float h2=(p1p2+p1p3+p2p3)*(p1p2+p1p3-p2p3)*(p1p2-p1p3+p2p3)*(-p1p2+p1p3+p2p3);
		TRACE("h^2 secondo:%f\n",.25*h2/((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y)));
		return h2<=4*soglia*soglia*((p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y));
	};
	//*/
	return FALSE;
}

BOOL CSpilinEditorDoc::inscorrel(CPoint punto)
{
	if (!chiusa)
	{
		// check on initial linear segment
		if(numnodi>=2 && Dist(listaprimo->pun,listaprimo->succ->pun,punto,5.0f))
		{
			corr=listaprimo->succ;
			return TRUE;
		};
		// check on final linear segment
		if (numnodi>=3 && Dist(listaultimo->pun,listaultimo->prec->pun,punto,5.0f))
		{
			corr=listaultimo;
			return TRUE;
		};
		// check on spline curve
		if(numnodi>=3)
		{
			BOOLEAN flag=FALSE;
			int xp,yp;
			float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
			nodo *vpunt[4];
			delta=float(1./numsteps);
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[2]->succ;
			while (vpunt[3]!=NULL && !flag)
			{
				ax=float(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
				bx=float(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
				cx=float(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
				
				ay=float(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
				by=float(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
				cy=float(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
			
				x=float(vpunt[1]->pun.x);
				dex=((ax*delta+bx)*delta+cx)*delta;
				de2x=(6*ax*delta+2*bx)*delta*delta;
				de3x=6*ax*delta*delta*delta;
				
				y=float(vpunt[1]->pun.y);
				dey=((ay*delta+by)*delta+cy)*delta;
				de2y=(6*ay*delta+2*by)*delta*delta;
				de3y=6*ay*delta*delta*delta;
				
				for(int j=1;j<=numsteps;j++)
				{
					xp=int(floor(x+.5));
					yp=int(floor(y+.5));
					x+=dex;
					dex+=de2x;
					de2x+=de3x;
					y+=dey;
					dey+=de2y;
					de2y+=de3y;
					if (Dist(CPoint(int(floor(x+.5)),int(floor(y+.5))),CPoint(xp,yp),punto,5.0f))
					{
						corr=vpunt[2];
						flag=TRUE;
					};
				};
				vpunt[0]=vpunt[0]->succ;
				vpunt[1]=vpunt[1]->succ;
				vpunt[2]=vpunt[2]->succ;
				vpunt[3]=vpunt[3]->succ;
			};
			return flag;
		};
	}
	else // closed spline (3 nodes too)
	{
		BOOLEAN flag=FALSE;
		int xp,yp;
		float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
		nodo *vpunt[4];
		delta=float(1./numsteps);
		if (numnodi==3){
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[0];
		}
		else{
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[2]->succ;
		};
		do{
			ax=.5f*float((-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
			bx=.5f*float((2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
			cx=.5f*float((-vpunt[0]->pun.x+vpunt[2]->pun.x));
			
			ay=.5f*float((-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
			by=.5f*float((2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
			cy=.5f*float((-vpunt[0]->pun.y+vpunt[2]->pun.y));
		
			x=float(vpunt[1]->pun.x);
			dex=((ax*delta+bx)*delta+cx)*delta;
			de2x=(6*ax*delta+2*bx)*delta*delta;
			de3x=6*ax*delta*delta*delta;
			
			y=float(vpunt[1]->pun.y);
			dey=((ay*delta+by)*delta+cy)*delta;
			de2y=(6*ay*delta+2*by)*delta*delta;
			de3y=6*ay*delta*delta*delta;
			
			for(int j=1;j<=numsteps;j++)
			{
				xp=int(floor(x+.5));
				yp=int(floor(y+.5));
				x+=dex;
				dex+=de2x;
				de2x+=de3x;
				y+=dey;
				dey+=de2y;
				de2y+=de3y;
				if (Dist(CPoint(int(floor(x+.5)),int(floor(y+.5))),CPoint(xp,yp),punto,5.0f))
				{
					corr=vpunt[2];
					flag=TRUE;
				};
			};
			vpunt[0]=vpunt[0]->succ!=NULL ? vpunt[0]->succ : listaprimo;
			vpunt[1]=vpunt[1]->succ!=NULL ? vpunt[1]->succ : listaprimo;
			vpunt[2]=vpunt[2]->succ!=NULL ? vpunt[2]->succ : listaprimo;
			vpunt[3]=vpunt[3]->succ!=NULL ? vpunt[3]->succ : listaprimo;
		}
		while (vpunt[0]!=listaprimo && !flag);
		return flag;
	};
	return FALSE;
}
/* old code - backup copy
BOOL CSpilinEditorDoc::inscorrel(CPoint punto)
{
	// controllo sul segmento iniziale
	if(numnodi>=2)
	{
		CRect r(listaprimo->pun,listaprimo->succ->pun);
		r.NormalizeRect();
		if (r.PtInRect(punto))
		{
			float m=float(listaprimo->succ->pun.y-listaprimo->pun.y)/float(listaprimo->succ->pun.x-listaprimo->pun.x);
			int dy=abs(int(m*float(punto.x-listaprimo->pun.x))+listaprimo->pun.y-punto.y);
			if (dy<5) {corr=listaprimo->succ;return TRUE;};
		};
	};
	// controllo sul segmento finale
	if (numnodi>=3)
	{
		CRect r(listaultimo->pun,listaultimo->prec->pun);
		r.NormalizeRect();
		if (r.PtInRect(punto))
		{
			float m=float(listaultimo->prec->pun.y-listaultimo->pun.y)/float(listaultimo->prec->pun.x-listaultimo->pun.x);
			int dy=abs(int(m*float(punto.x-listaultimo->pun.x))+listaultimo->pun.y-punto.y);
			if (dy<5) {corr=listaultimo;return TRUE;};
		};
	};
	// controllo sui segmenti di curva intermedi
	if(numnodi>=4)
	{
		BOOLEAN flag=FALSE;
		int dx;int dy=0;
		float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
		nodo *vpunt[4];
		delta=float(1./numsteps);
		vpunt[0]=listaprimo;
		vpunt[1]=vpunt[0]->succ;
		vpunt[2]=vpunt[1]->succ;
		vpunt[3]=vpunt[2]->succ;
		while (vpunt[3]!=NULL && !flag)
		{
			ax=float(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
			bx=float(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
			cx=float(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
			
			ay=float(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
			by=float(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
			cy=float(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
		
			x=float(vpunt[1]->pun.x);
			dex=ax*delta*delta*delta+bx*delta*delta+cx*delta;
			de2x=6*ax*delta*delta*delta+2*bx*delta*delta;
			de3x=6*ax*delta*delta*delta;
			
			y=float(vpunt[1]->pun.y);
			dey=ay*delta*delta*delta+by*delta*delta+cy*delta;
			de2y=6*ay*delta*delta*delta+2*by*delta*delta;
			de3y=6*ay*delta*delta*delta;
			
			for(int j=1;j<=numsteps;j++)
			{
				x+=dex;
				dex+=de2x;
				de2x+=de3x;
				y+=dey;
				dey+=de2y;
				de2y+=de3y;
				dx=abs(int(floor(x+.5))-punto.x);
				dy=abs(int(floor(y+.5))-punto.y);
				if (dx<5 && dy<5) {corr=vpunt[2];flag=TRUE;}
			};
			vpunt[0]=vpunt[0]->succ;
			vpunt[1]=vpunt[1]->succ;
			vpunt[2]=vpunt[2]->succ;
			vpunt[3]=vpunt[3]->succ;
		};
		return flag;
	}
	return FALSE;
}
*/
void CSpilinEditorDoc::CheckPovPrimitive(BOOL &sorwarn, BOOL &rotateintersect,float &max,int &ymax)
{
	ASSERT(numnodi>=3);
	sorwarn=FALSE;
	rotateintersect=FALSE;
	max=0.0f;
	float xmin,ymin,xmax,ymaxx;
	xmax=ymaxx=0.0f;
	xmin=ymin=FLT_MAX;
	if(!chiusa)
	{
		if (numnodi>=4)//standard open splines
		{
			float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
			nodo *vpunt[4];
			delta=1.0f/float(numsteps);
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[2]->succ;
			sorwarn=(vpunt[1]->pun.y > vpunt[0]->pun.y) || (vpunt[2]->pun.y > vpunt[1]->pun.y);
			while (vpunt[3]!=NULL)
			{
				sorwarn|=(vpunt[3]->pun.y>vpunt[2]->pun.y);
				
				ax=float(.5*(-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
				bx=float(.5*(2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
				cx=float(.5*(-vpunt[0]->pun.x+vpunt[2]->pun.x));
				
				ay=float(.5*(-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
				by=float(.5*(2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
				cy=float(.5*(-vpunt[0]->pun.y+vpunt[2]->pun.y));
			
				x=float(vpunt[1]->pun.x);
				dex=((ax*delta+bx)*delta+cx)*delta;
				de2x=(6*ax*delta+2*bx)*delta*delta;
				de3x=6*ax*delta*delta*delta;
				
				y=float(vpunt[1]->pun.y);
				dey=((ay*delta+by)*delta+cy)*delta;
				de2y=(6*ay*delta+2*by)*delta*delta;
				de3y=6*ay*delta*delta*delta;
				
				for(int j=1;j<=numsteps;j++)
				{
					x+=dex;
					dex+=de2x;
					de2x+=de3x;
					y+=dey;
					dey+=de2y;
					de2y+=de3y;
					rotateintersect|=(x<0 || y<0);
					ymaxx=(y>ymaxx)?y:ymaxx;
					xmax=(x>xmax)?x:xmax;
					ymin=(y<ymin)?y:ymin;
					xmin=(x<xmin)?x:xmin;
				};
				vpunt[0]=vpunt[0]->succ;
				vpunt[1]=vpunt[0]->succ;
				vpunt[2]=vpunt[1]->succ;
				vpunt[3]=vpunt[2]->succ;
			};
			max=(xmax-xmin)>(ymaxx-ymin)?float(xmax-xmin):float(ymaxx-ymin);
			ymax=int(floor(ymaxx+0.5f));
		}
		else// less 4 nodes, open spline (not very useful but possible)
		{
			#define primo listaprimo->pun
			#define secondo listaprimo->succ->pun
			#define terzo listaprimo->succ->succ->pun
			sorwarn=(secondo.y > primo.y) || (terzo.y > secondo.y);
			ymax=(primo.y>ymax)?primo.y:ymax;
			ymax=(secondo.y>ymax)?secondo.y:ymax;
			ymax=(terzo.y>ymax)?terzo.y:ymax;

			xmax=(primo.x>xmax)?primo.x:xmax;
			xmax=(secondo.x>xmax)?secondo.x:xmax;
			xmax=(terzo.x>xmax)?terzo.x:xmax;

			xmin=(primo.x<xmin)?primo.x:xmin;
			xmin=(secondo.x<xmin)?secondo.x:xmin;
			xmin=(terzo.x<xmin)?terzo.x:xmin;

			ymin=(primo.y<ymin)?primo.y:ymin;
			ymin=(secondo.y<ymin)?secondo.y:ymin;
			ymin=(terzo.y<ymin)?terzo.y:ymin;

			max=(xmax-xmin)>(ymax-ymin)?float(xmax-xmin):float(ymax-ymin);
		};
	}
	else // closed spline (3 nodes too)
	{
		float ax,bx,cx,ay,by,cy,delta,x,dex,de2x,de3x,y,dey,de2y,de3y;
		nodo *vpunt[4];
		delta=float(1./numsteps);
		if (numnodi==3){
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[0];
		}
		else{
			vpunt[0]=listaprimo;
			vpunt[1]=vpunt[0]->succ;
			vpunt[2]=vpunt[1]->succ;
			vpunt[3]=vpunt[2]->succ;
		};
		do{
			ax=.5f*float((-vpunt[0]->pun.x+3*vpunt[1]->pun.x-3*vpunt[2]->pun.x+vpunt[3]->pun.x));
			bx=.5f*float((2*vpunt[0]->pun.x-5*vpunt[1]->pun.x+4*vpunt[2]->pun.x-vpunt[3]->pun.x));
			cx=.5f*float((-vpunt[0]->pun.x+vpunt[2]->pun.x));
			
			ay=.5f*float((-vpunt[0]->pun.y+3*vpunt[1]->pun.y-3*vpunt[2]->pun.y+vpunt[3]->pun.y));
			by=.5f*float((2*vpunt[0]->pun.y-5*vpunt[1]->pun.y+4*vpunt[2]->pun.y-vpunt[3]->pun.y));
			cy=.5f*float((-vpunt[0]->pun.y+vpunt[2]->pun.y));
		
			x=float(vpunt[1]->pun.x);
			dex=((ax*delta+bx)*delta+cx)*delta;
			de2x=(6*ax*delta+2*bx)*delta*delta;
			de3x=6*ax*delta*delta*delta;
			
			y=float(vpunt[1]->pun.y);
			dey=((ay*delta+by)*delta+cy)*delta;
			de2y=(6*ay*delta+2*by)*delta*delta;
			de3y=6*ay*delta*delta*delta;
			
			for(int j=1;j<=numsteps;j++)
			{
				x+=dex;
				dex+=de2x;
				de2x+=de3x;
				y+=dey;
				dey+=de2y;
				de2y+=de3y;
				rotateintersect|=(x<0 || y<0);
				ymaxx=(y>ymaxx)?y:ymaxx;
				xmax=(x>xmax)?x:xmax;
				ymin=(y<ymin)?y:ymin;
				xmin=(x<xmin)?x:xmin;
			};
			vpunt[0]=vpunt[0]->succ!=NULL ? vpunt[0]->succ : listaprimo;
			vpunt[1]=vpunt[1]->succ!=NULL ? vpunt[1]->succ : listaprimo;
			vpunt[2]=vpunt[2]->succ!=NULL ? vpunt[2]->succ : listaprimo;
			vpunt[3]=vpunt[3]->succ!=NULL ? vpunt[3]->succ : listaprimo;
		}
		while (vpunt[0]!=listaprimo);
		max=(xmax-xmin)>(ymaxx-ymin)?float(xmax-xmin):float(ymaxx-ymin);
		ymax=int(floor(ymaxx+0.5f));
	};
	TRACE("max %f ymax %d sorwarn %d rotateintersect %d\n",max,ymax,sorwarn,rotateintersect);
}

void CSpilinEditorDoc::SpostaTuttiNodi(char dir,int gridsize)
{
	ASSERT(dir>0 && dir<5);
	ASSERT(gridsize>0);
	int deltax=0,deltay=0;
	switch(dir)
	{
	case 1: deltay-=gridsize;
		break;
	case 2: deltay+=gridsize;
		break;
	case 3: deltax-=gridsize;
		break;
	case 4: deltax+=gridsize;
		break;
	};
	nodo* pnod=listaprimo;
	int temp;
	while (pnod!=NULL)
	{
		temp=pnod->pun.x+deltax;
		pnod->pun.x=temp>0?temp:0;
		temp=pnod->pun.y+deltay;
		pnod->pun.y=temp>0?temp:0;
		pnod=pnod->succ;
	};
	UpdateAllViews(NULL);

}

void CSpilinEditorDoc::OnUpdateSteps(CCmdUI *pCmdUI)
{
	pCmdUI->Enable();
	CString st;
	st.Format("Steps: %d",numsteps);
    pCmdUI->SetText(st);
}

void CSpilinEditorDoc::OnUpdateNodi(CCmdUI *pCmdUI)
{
	pCmdUI->Enable();
	CString st;
	st.Format("Nodes: %d",numnodi);
    pCmdUI->SetText(st);
}

void CSpilinEditorDoc::OnUpdatePolygons(CCmdUI *pCmdUI)
{
	pCmdUI->Enable();
	CString st;
	int numpolyg;
	switch(pGLView->objtype)
	{
	case LATHE: numpolyg=(sezsolido-1)*((numnodi-2+(numnodi-3)*(numstepspreview-1))-1);
					st.Format("Polygons: %d",numpolyg>0?numpolyg:0);
					break;
	case PRISM: numpolyg=3*((numnodi-2+(numnodi-3)*(numstepspreview-1))-1);
					st.Format("Polygons: ~%d",numpolyg>0?numpolyg:0);
					break;
	};
    pCmdUI->SetText(st);
}

void CSpilinEditorDoc::OnFlipN() 
{
	pviewnormflip^=1;
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::GeometryUpdate(BOOL &culling)
{
	culling=FALSE;
	if (chiusa) 
	{
		culling=TRUE;
		genExtrusion();
	};
	if(numnodi>3 || chiusa) 
	{
		genRevolution();
		if (listaprimo->succ->pun.x==0 && listaultimo->prec->pun.x==0) culling=TRUE;
	};
}

void CSpilinEditorDoc::Clamping(CPoint &punto)
{
	punto.x=(punto.x>=0)?punto.x:0;
	punto.y=(punto.y>=0)?punto.y:0;
}

void CSpilinEditorDoc::OnEditRedo() 
{
	Redo();
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::OnEditUndo() 
{
	Undo();
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(CanUndo() );
}

void CSpilinEditorDoc::OnUpdateEditRedo(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(CanRedo() );	
}

void CSpilinEditorDoc::OnEditCopy() 
{
	PovToClipboard(pGLView->objtype);
}

void CSpilinEditorDoc::SelectAllPoint() 
{
// versione semplice
	nodo* pnod=listaprimo;
		while (pnod!=NULL)
		{
			pnod->selected=TRUE;
			pnod=pnod->succ;
		};
/* versione con scansione doppia - da completare -
	if (numnodi>0)
	{
		nodo *punti=listaprimo;
		nodo *puntf=listaultimo;
		while(punti!=NULL && puntf!=NULL && punti!=puntf)
		{
			punti->selected=TRUE;
			puntf->selected=TRUE;
			punti=punti->succ;
			puntf=puntf->prec;
		};
	};
//*/
	pEditView->SelVectorLenght=numnodi;
	pEditView->CreateSelVect();
	UpdateEditView();
}

void CSpilinEditorDoc::OnSnap() 
{
	pEditView->ToggleGrid();
}

void CSpilinEditorDoc::OnRevolution() 
{
	pGLView->objtype=LATHE;
	UpdateGLView();
}

void CSpilinEditorDoc::OnUpdateRevolution(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pGLView->objtype==LATHE);
}

void CSpilinEditorDoc::OnEstrusion() 
{
	pGLView->objtype=PRISM;
	UpdateGLView();
}

void CSpilinEditorDoc::OnUpdateEstrusion(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(chiusa);
	pCmdUI->SetCheck(pGLView->objtype==PRISM);
}

void CSpilinEditorDoc::OnSmoothShade() 
{
	pGLView->ToggleSmoothShading();
}

void CSpilinEditorDoc::OnViewGridplane() 
{
	pGLView->ShowGridPlane^=1;
	UpdateGLView();
}

void CSpilinEditorDoc::OnStatoCrea() 
{
	pEditView->SetMode(CSpilinEditorView::CREA);
}

void CSpilinEditorDoc::OnStatoInser() 
{
	pEditView->SetMode(CSpilinEditorView::INSERISCI);
}

void CSpilinEditorDoc::OnStatoModifica() 
{
	pEditView->SetMode(CSpilinEditorView::MODIFICA);
}

void CSpilinEditorDoc::OnStatoSelect() 
{
	pEditView->SetMode(CSpilinEditorView::SELEZIONA);
}

void CSpilinEditorDoc::OnStatoRuota() 
{
	pEditView->SetMode(CSpilinEditorView::RUOTA);
}

void CSpilinEditorDoc::OnStatoScala() 
{
	pEditView->SetMode(CSpilinEditorView::SCALA);
}

int CSpilinEditorDoc::SelectInRect(CRect rett)
{
	int Lenght=0;
	rett.NormalizeRect();
	nodo* pnod=listaprimo;
	while (pnod!=NULL)
	{
		if(rett.PtInRect(pnod->pun)) {
			pnod->selected=TRUE;
			corr=pnod;
			Lenght++;
		}
		else pnod->selected=FALSE;
		pnod=pnod->succ;
	};
	return Lenght;
}

void CSpilinEditorDoc::FixSelDocVect()
{
	CheckPoint();
	SetModifiedFlag();
}

void CSpilinEditorDoc::SelectSingle(nodo * punt)
{
	punt->selected=TRUE;
}

void CSpilinEditorDoc::SelectCurrent(BOOL add)
{
	if(corr != NULL){
		if(!add)SelectNoPoint();
		corr->selected=TRUE;
	};
}

void CSpilinEditorDoc::SelectNoPoint() 
{
// versione semplice
	nodo* pnod=listaprimo;
		while (pnod!=NULL)
		{
			pnod->selected=FALSE;
			pnod=pnod->succ;
		};
/* versione con scansione doppia - da completare -
	if (numnodi>0)
	{
		nodo *punti=listaprimo;
		nodo *puntf=listaultimo;
		while(punti!=NULL && puntf!=NULL && punti!=puntf)
		{
			punti->selected=FALSE;
			puntf->selected=FALSE;
			punti=punti->succ;
			puntf=puntf->prec;
		};
	};
//*/
	pEditView->DeleteSelVect();
	UpdateEditView();
}

void CSpilinEditorDoc::SpostaSelectNodi(char dir, int gridsize)
{
	ASSERT(dir>0 && dir<5);
	ASSERT(gridsize>0);
	int deltax=0,deltay=0;
	switch(dir)
	{
	case 1: deltay-=gridsize;
		break;
	case 2: deltay+=gridsize;
		break;
	case 3: deltax-=gridsize;
		break;
	case 4: deltax+=gridsize;
		break;
	};
// simple method
	nodo* pnod=listaprimo;
	int temp=0;
	while (pnod!=NULL)
	{
		if(pnod->selected)
		{
			temp=pnod->pun.x+deltax;
			pnod->pun.x=temp>0?temp:0;
			temp=pnod->pun.y+deltay;
			pnod->pun.y=temp>0?temp:0;
		};
		pnod=pnod->succ;
	};
	UpdateEditView();
}

void CSpilinEditorDoc::SelectNextPoint()
{
	nodo* pnod=listaprimo;
	while (pnod!=NULL && !pnod->selected) pnod=pnod->succ;
	if(pnod!=NULL ) pnod->selected=FALSE;
	if (pnod->succ != NULL) pnod->succ->selected=TRUE;
	else listaprimo->selected=TRUE;
}

void CSpilinEditorDoc::OnSettings() 
{
	CSettingSheet pSheet;
	CallSettingSheet(pSheet);
}

int CSpilinEditorDoc::CallSettingSheet(CSettingSheet & propSheet)
{
	CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
	CSpilinEditorView* pEditView=STATIC_DOWNCAST(CSpilinEditorView, pFrame->m_wndSplitter.GetPane(0,0) );
	ASSERT_VALID(pEditView);
	CGLView*  pGLView=STATIC_DOWNCAST(CGLView, pFrame->m_wndSplitter.GetPane(0,1) );
	ASSERT_VALID(pGLView);
	propSheet.SetTitle("Settings...");
	// Edit View vars
	propSheet.m_Page1.m_gridsize=pEditView->snapSize;
	propSheet.m_Page1.m_pensize=pEditView->DimPenna;
	propSheet.m_Page1.m_bgcolor=pEditView->bgcolor;
	propSheet.m_Page1.m_pencolor=pEditView->pencolor;
	propSheet.m_Page1.m_gridcolor=pEditView->gridcolor;
	propSheet.m_Page1.m_drawpolyg=pEditView->drawnodespolygon;
	//Doc vars
	propSheet.m_Page1.m_curvesteps=numsteps;
	propSheet.m_Page2.m_3dsteps=numstepspreview;
	propSheet.m_Page2.m_sections=sezsolido;
	propSheet.m_Page2.m_extrusion=pviewHeight;
	propSheet.m_Page4.m_altez=exportHeight;
	propSheet.m_Page4.m_open=exportOpen;
	propSheet.m_Page4.m_sturm=exportSturm;
	propSheet.m_Page4.m_conic=exportConic;
	propSheet.m_Page4.m_ptype=(int)exportObjType;
	propSheet.m_Page4.m_propfactor=cmapfactor;
	propSheet.m_Page4.m_proportional=!proportional;
	propSheet.m_Page4.m_objname=exportObjName;
	//GLView vars
	propSheet.m_Page2.m_objbackcull=pGLView->backcull;
	propSheet.m_Page2.m_objsmooth=pGLView->smoothshade;
	propSheet.m_Page2.m_objcolor=pGLView->colpreview;
	propSheet.m_Page3.m_flcolor=pGLView->colfrontlight;
	propSheet.m_Page3.m_blcolor=pGLView->colbacklight;
	propSheet.m_Page3.m_3dbgcolor=pGLView->bgcolor;
	propSheet.m_Page3.m_gpcolor=pGLView->gpcolor;
	propSheet.m_Page3.m_flpos=pGLView->FrontLightPos;
	propSheet.m_Page3.m_blpos=pGLView->BackLightPos;
	int result=propSheet.DoModal();
	if(result==IDOK)
	{
		pEditView->snapSize = propSheet.m_Page1.m_gridsize;
		pEditView->DimPenna = propSheet.m_Page1.m_pensize;
		pEditView->bgcolor = propSheet.m_Page1.m_bgcolor;
		pEditView->pencolor=propSheet.m_Page1.m_pencolor;
		pEditView->gridcolor=propSheet.m_Page1.m_gridcolor;
		pEditView->drawnodespolygon=propSheet.m_Page1.m_drawpolyg;
		
		numsteps=propSheet.m_Page1.m_curvesteps;
		numstepspreview	=propSheet.m_Page2.m_3dsteps;
		sezsolido=propSheet.m_Page2.m_sections;
		pviewHeight=propSheet.m_Page2.m_extrusion;
		exportHeight=propSheet.m_Page4.m_altez;
		exportObjType=(primitiva)propSheet.m_Page4.m_ptype;
		cmapfactor=propSheet.m_Page4.m_propfactor;
		proportional=!propSheet.m_Page4.m_proportional;
		exportObjName=propSheet.m_Page4.m_objname;
		exportOpen=propSheet.m_Page4.m_open;
		exportSturm=propSheet.m_Page4.m_sturm;
		exportConic=propSheet.m_Page4.m_conic;

		pGLView->backcull=propSheet.m_Page2.m_objbackcull;
		if(propSheet.m_Page2.m_objsmooth != pGLView->smoothshade) pGLView->ToggleSmoothShading();
		pGLView->colpreview=propSheet.m_Page2.m_objcolor;
		pGLView->colfrontlight=propSheet.m_Page3.m_flcolor;
		pGLView->colbacklight=propSheet.m_Page3.m_blcolor;
		pGLView->bgcolor=propSheet.m_Page3.m_3dbgcolor;
		pGLView->gpcolor=propSheet.m_Page3.m_gpcolor;
		pGLView->FrontLightPos=(LightPosition)propSheet.m_Page3.m_flpos;
		pGLView->BackLightPos=(LightPosition)propSheet.m_Page3.m_blpos;

		pGLView->UpdateColors();
		UpdateAllViews(NULL);
	}
	return result;
}

void CSpilinEditorDoc::OnUpdateViewGridplane(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pGLView->ShowGridPlane);
}

void CSpilinEditorDoc::OnUpdateStatoRuota(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(pEditView->SelVectorLenght>1);
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::RUOTA));
}

void CSpilinEditorDoc::OnUpdateStatoCrea(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::CREA));
}

void CSpilinEditorDoc::OnUpdateStatoInser(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::INSERISCI));
}

void CSpilinEditorDoc::OnUpdateStatoModifica(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::MODIFICA));
}

void CSpilinEditorDoc::OnUpdateStatoSelect(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::SELEZIONA));
}

void CSpilinEditorDoc::OnUpdateStatoScala(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(pEditView->SelVectorLenght>1);
	pCmdUI->SetCheck(pEditView->IsMode(CSpilinEditorView::SCALA));
}

void CSpilinEditorDoc::CancSelNodes()
{
	pEditView->DeleteSelVect();
// simple method (single list scan)
	nodo* pnod=listaprimo;
	nodo* temp;
	while (pnod!=NULL)
	{
		if(pnod->selected)
		{
		temp=pnod;
		if (pnod->succ!=NULL) pnod->succ->prec=pnod->prec;
		else listaultimo=pnod->prec;
		if (pnod->prec!=NULL) pnod->prec->succ=pnod->succ;
		else listaprimo=pnod->succ;
		if (pnod->prec!=NULL) pnod=pnod->prec;
		else pnod=listaprimo;
		delete temp;
		numnodi-=1;
		};
		pnod=pnod->succ;
	};
	chiusa=(chiusa==TRUE) ? !(numnodi<=2) : FALSE;
	CheckPoint();
	SetModifiedFlag();
	UpdateAllViews(NULL);
}

void CSpilinEditorDoc::OnStatoMirrorX() 
{
	if(pEditView->SelVectorLenght>1 && pEditView->SelVector!=NULL)
	{
		pEditView->MirrorSelVect(TRUE);
		pEditView->FixSelVect();
		UpdateAllViews(NULL);
	}
}

void CSpilinEditorDoc::OnStatoMirrorY() 
{
	if(pEditView->SelVectorLenght>1 && pEditView->SelVector!=NULL)
	{
		pEditView->MirrorSelVect(FALSE);
		pEditView->FixSelVect();
		UpdateAllViews(NULL);
	}
}

CPoint CSpilinEditorDoc::CenterOfSelectedPoints()
{
	CPoint risult(0,0);
	int cont=0;
	for(nodo* pnod=listaprimo;pnod!=NULL;pnod=pnod->succ)
		if(pnod->selected)
		{
			risult+=pnod->pun;
			cont++;
		};
	if (cont>0) {risult.x/=cont;risult.y/=cont;}
	else risult=CPoint(-5,-5);
	return risult;
}

void CSpilinEditorDoc::OnModificaChiudispline() 
{
	if(chiusa)
	{
		//opens a closed spline
		chiusa=FALSE;
		CheckPoint();
		SetModifiedFlag();
		UpdateAllViews(NULL);
	}
	else if(numnodi>=3){
		//closes a spline with at least 3 nodes
		chiusa=TRUE;
		CheckPoint();
		SetModifiedFlag();
		UpdateAllViews(NULL);
	};
}

inline void CSpilinEditorDoc::OnEditSelectAll() 
{
	SelectAllPoint();
}

inline void CSpilinEditorDoc::OnEditSelectNone() 
{
	SelectNoPoint();
}

void CSpilinEditorDoc::UpdateEditView()
{
	pEditView->Invalidate(TRUE);
	pEditView->UpdateWindow();
}

void CSpilinEditorDoc::UpdateGLView()
{
	pGLView->Invalidate(TRUE);
	pGLView->UpdateWindow();
}

void CSpilinEditorDoc::RetrieveSettings()
{
	CWinApp* pApp=AfxGetApp();
	proportional=pApp->GetProfileInt("Settings", "PropMapping",1);
	cmapfactor=pApp->GetProfileInt("Settings", "ProportionalFactor",1);
	numsteps=pApp->GetProfileInt("Settings", "EditorSteps",10);
	numstepspreview=pApp->GetProfileInt("Settings", "PreviewSteps",5);
	sezsolido=pApp->GetProfileInt("Settings", "Sections",24);
	int temp=pApp->GetProfileInt("Settings", "ExtrusionHeight",50000);
	pviewHeight=temp>0?temp/100000.f:1;
}

void CSpilinEditorDoc::SaveSettings()
{
	CWinApp* pApp=AfxGetApp();
	pApp->WriteProfileInt("Settings", "PropMapping",proportional);
	pApp->WriteProfileInt("Settings", "ProportionalFactor",cmapfactor);
	pApp->WriteProfileInt("Settings", "EditorSteps",numsteps);
	pApp->WriteProfileInt("Settings", "PreviewSteps",numstepspreview);
	pApp->WriteProfileInt("Settings", "Sections",sezsolido);
	int temp=int(pviewHeight*100000);
	pApp->WriteProfileInt("Settings", "ExtrusionHeight",temp>0?temp:100000);
}

void CSpilinEditorDoc::OnUpdateStatoMirrorX(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(pEditView->SelVectorLenght>1);
}

void CSpilinEditorDoc::OnUpdateStatoMirrorY(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(pEditView->SelVectorLenght>1);
}

void CSpilinEditorDoc::OnUpdateModificaChiudispline(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(numnodi>2);
}
